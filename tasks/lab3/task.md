Руководство и задания к 3-ей практике. На практике поработаем с маршрутами, с параметрами запросов. 
Поработаем с фильтрацией товаров и импровизированной корзиной покупок с выводом результатов как JSON.

### 1. Работа с вложенными маршрутами

Ранее мы писали все маршруты в корневом файле `urls.py`, что может быть достаточно неудобно, особенно когда маршрутов будет много приложений, когда 
каждое приложение внутри себя обрабатывает несколько маршрутов. Пример приложение `store` от него в `urls.py` уже используется
2 маршрута (`'product/'` и `''`).

На практике можно в корневом `urls.py` прописывать только файл с маршрутами приложения, а Django уже сам подтянет
маршруты из приложения, так структура становится более читаемая.

Для этого создадим файл `urls.py` в приложении `store`, где пропишем маршруты скопированные из корневого `urls.py` (в папке `project`).
Маршруты располагаются во всё той же переменной `urlpatterns` - это зарезервированная переменная в Django, в которой предполагается 
хранение маршрутов обработки представлений. 

```python
# urls.py in store

from django.urls import path
from .views import products_view, shop_view

urlpatterns = [
    path('product/', products_view),
    path('', shop_view),
]
```

Далее в корневом `urls.py` необходимо поправить прошлые маршруты, для это воспользуемся функцией `include`
позволяющая указать приложение, а Django самостоятельно возьмёт маршруты из переменной `urlpatterns` приложения.

Вот как трансформируются маршруты приложения `store` в корневом `urls.py`

```python
path('', include('store.urls')),
```
А корневой `urls.py` будет выглядеть так

![1.png](pic_for_task/1.png)

Теперь ссылки, что были доступны ранее для приложения `store` также доступны.

#### Самостоятельно

Самостоятельно перепишите маршрут с использованием `include` для приложения `app_weather`,
но сделайте так, чтобы тот маршрут, по которому ранее обрабатывался прогноз погоды - также обрабатывался.

Допустим если до использования `include` - прогноз погоды был доступен по адресу http://127.0.0.1:8000/weather/ ,
то после использования `include` - адрес доступа сохранился.


### 2. Работа с параметрами запроса

Ранее в приложении прогноза погоды, мы не могли изменить координату через адресную строку,
приходилось менять это значение в коде, теперь давайте сделаем код более гибким и будем брать
значения координат для прогноза погоды из прааметров GET запроса.

Получить данные из запроса, можно из переменной `request` вашей функции представления. Для этого обратитесь к переменной
`GET` объекта `request` (`request.GET`), в котором будет `словарь`, где ключи словаря - переменные в запросе, значения - значения 
переменных в запросе.

Допустим при обработке запроса `https://example.ru?q=запрос&a=ответ` из `request.GET` 
получим словарь `{'q': 'запрос', 'a': 'ответ'}`, который можно использовать для своих нужд.

Тогда код представления для прогноза погоды будет следующим.

```python
from django.http import JsonResponse
from weather_api import current_weather


def weather_view(request):
    if request.method == "GET":
        lat = request.GET.get('lat')  # данные придут в виде строки
        lon = request.GET.get('lon')  # данные придут в виде строки
        if lat and lon:
            data = current_weather(lat=lat, lon=lon)
        else:
            data = current_weather(59.93, 30.31)
        return JsonResponse(data, json_dumps_params={'ensure_ascii': False,
                                                     'indent': 4})
```

И теперь к сервер берет данные из строки запроса и работает с ними. Допустим так
можем узнать погоду в Москве http://127.0.0.1:8000/weather?lat=55.75&lon=37.61 

А если ничего не передать, то погоду будет в Санкт-Петербурге http://127.0.0.1:8000/weather .

#### Самостоятельно

Доработайте представление `products_view` приложения `store` так, чтобы через параметры запроса `id` 
представление реализовывало следующий функционал:
* Если `id` было передано в запросе и такой ключ существует в `DATABASE`, то представление возвращает характеристики товара
* Если `id` было передано в запросе и такого ключа НЕ существует в `DATABASE`, то представление возвращает 
`HttpResponseNotFound("Данного продукта нет в базе данных")`
* Если `id` НЕ было передано в запросе, то возвращает все товары.

Пример файла `view.py` приложения `store` 

```python
from django.http import JsonResponse, HttpResponse, HttpResponseNotFound
from .models import DATABASE


def products_view(request):
    if request.method == "GET":
        # Ваша реализация
```

Проверьте, что ваше представление отрабатывает все случаи:

* 'Нет продукта' - http://127.0.0.1:8000/product/?id=0

* 'Один продукт' - http://127.0.0.1:8000/product/?id=3

* 'Все продукты' - http://127.0.0.1:8000/product/

### 3. Работа с параметрами запроса через обработчик маршрутов Django

Скопируем папку `products` из папки `files/lab3` в папку `store`. В папке приведены HTML страницы товаров
разрабатываемого магазина. Можете открыть данные файлы в превью ли браузере и ознакомиться с данным файлом.
Если пролистать вниз в этом файле, то в разделе товары той же категории можете нажать на товары и перейти на соответствующие продукты.

![2.png](pic_for_task/2.png)

Сделаем возможность отобразить наши товары с использованием Django и в более информативном виде, чем JSON объект. 
Будем возвращать HTML файлы (как в прошлой работе).

Для этого во `views.py` приложения `store` создадим новое представление `products_page_view` (так как представление 
`products_view` у нас возвращает объект JSON)

*Передача параметров с типом `slug`*

В `products_page_view` передадим параметр `page`, он будет идентификатором страницы, по этому идентификатору мы будем понимать,
что за страница нужна для отображения. Сейчас примем тот факт, что переменная `page` будет строкового типа с именем `html`
страницы которую будем отображать.

Заполните шаблон представления

```python
def products_page_view(request, page):
    if request.method == "GET":
        for data in DATABASE.values():
            if data['html'] == page:  # Если значение переданного параметра совпадает именем html файла
                # TODO 1. Откройте файл open(f'store/products/{page}.html', encoding="utf-8") (Не забываем про контекстный менеджер with)
                # TODO 2. Прочитайте его содержимое
                # TODO 3. Верните HttpResponse c содержимым html файла
        
        # Если за всё время поиска не было совпадений, то значит по данному имени нет соответствующей 
        # страницы товара и можно вернуть ответ с ошибкой HttpResponse(status=404)
        return HttpResponse(status=404)
```

Теперь настроим обработку маршрутов

В `urls.py` приложения `store` пропишем маршрут с параметром `<``slug:page``>`

```python
path('product/<slug:page>.html', products_page_view),
```

Можно заметить, что у нас уже есть маршрут `product/` по которому возвращается JSON с нашими товарами. Так как маршруты
у нас разные и конфликтовать не будут, так как в первом случае ожидается путь вида `product/`, а во втором
путь вида `product/samyj-luchshij-tovar.html`

.html в параметре стоит просто для вида, она добавляется к запросу как часть пути, допустим

`http://127.0.0.1:8000/product/onion.html` - в данном конкретном случае Django разложит адрес на составляющие и передаст
`onion` в `products_page_view` как переменную `page`. Как в данном случае `products_page_view(..., page='onion')` ну, а далее
в зависимости найдёт он в базе данных совпадение или нет, то представление вернёт соответствующий результат.

Проверим работоспособность на примере http://127.0.0.1:8000/product/onion.html 

В нашем случае это будет страница товара "Лук"

![3.png](pic_for_task/3.png)

Если вдруг страница не отобразилась с CSS стилями и картинками, то не переживайте, далее это всё поправится и вызвано это тем, как 
подгружаются файлы из директорий. Это всё будет поправлено, когда будут созданы шаблоны.

Из реальных примеров типа `slug` может быть большинство интернет площадок с товарами, допустим на примере Ozon.
По данной ссылке откроется книга по Python, но нам важен не результат, что ссылка открылась, как сама ссылка

https://www.ozon.ru/product/chistyy-python-tonkosti-programmirovaniya-dlya-profi-beyder-den-211426197

Мы видим, что после  `www.ozon.ru/` далее идёт `product/`, а за ним идёт уже полезная нагрузка в виде названия и артикула(возможно).
И на примере путей Django можно было бы создать такой обработчик `'product/``<``slug:page``>``-``<``int:articul``>``'`. 
Который бы разбил адресную строку как бы нам было нужно.


*Передача параметров с типом `int`*

В нашем случае магазин маленький и можно облегчить задачу и передавать не только по имени товара, но и по его `id` в базе данных.

Здесь нам поможет параметр `int`. Создадим маршрут

```python
path('product/<int:page>', products_page_view),
```

Вы не ошиблись, мы создали 2 различных маршрута (один с `slug` другой с `int`) и привязали к одному представлению. Данный
подход имеет место на практике, но тогда необходимо переписать наше представление, чтобы оно могло обрабатывать
и тип `slug` и тип `int` который может прийти в переменной `page` функции `products_page_view`

Допишем данную функцию:

```python
def products_page_view(request, page):
    if request.method == "GET":
        if isinstance(page, str):
            # TODO Вставьте сюда тот код, что был ранее для обработки типа slug в products_page_view
        elif isinstance(page, int):
            data = DATABASE.get(str(page))  # Получаем какой странице соответствует данный id
            if data:  # Если по данному page было найдено значение 
                # TODO 1. Откройте файл open(f'store/products/{data["html"]}.html', encoding="utf-8") (Не забываем про контекстный менеджер with)
                # TODO 2. Прочитайте его содержимое
                # TODO 3. Верните HttpResponse c содержимым html файла

        return HttpResponse(status=404)
```

Теперь можно обратиться по адресу http://127.0.0.1:8000/product/9 , который вернет товар "Лук"

### 4. Фильтрация продуктов

Если зайти на главную страницу, http://127.0.0.1:8000/ , то можно увидеть разделы для групп товаров.

![4.png](pic_for_task/4.png)

Нашей текущей задачей будет реализовать фильтрацию, но реализуем мы её со стороны сервера, а визуальной реализацией займемся на следующей практике.

Что необходимо будет сделать:

Создадим папку `logic` в корне проекта (в папке DjangoPy110). В папке `logic` создадим файл `services.py` в нём мы будем
писать скрипты обработки данных.

В файле `services.py` напишем функцию `filtering_category` которая будет возвращать список товаров(список словарей с параметрами товаров)
выполняющие условия фильтрации. Ниже приведен шаблон данной функции, которую необходимо заполнить. Также приведен тестирующий пример, 
для проверки правильности работы.

```python
def filtering_category(database: dict[str, dict],
                       category_key: [None, str] = None,
                       ordering_key: [None, str] = None,
                       reverse: bool = False):
    """
    Функция фильтрации данных по параметрам

    :param database: База данных. (словарь словарей. При проверке в качестве database будет передаваться словарь DATABASE из models.py)
    :param category_key: [Опционально] Ключ для группировки категории. Если нет ключа, то рассматриваются все товары.
    :param ordering_key: [Опционально] Ключ по которому будет произведена сортировка результата.
    :param reverse: [Опционально] Выбор направления сортировки:
        False - сортировка по возрастанию;
        True - сортировка по убыванию.
    :return: list[dict] список товаров с их характеристиками, попавших под условия фильтрации. Если нет таких элементов,
    то возвращается пустой список
    """
    if category_key is not None:
        result = ...  #  TODO При помощи фильтрации в list comprehension профильтруйте товары по категории (ключ 'category') в продукте database. Или можете использовать
        # обычный цикл или функцию filter. Допустим фильтрацию в list comprehension можно сделать по следующему шаблону
        # [product for product in database.values() if ...] подумать, что за фильтрующее условие можно применить. 
        # Сравните значение категории продукта со значением category_key
    else:
        result = ... #  TODO Трансформируйте словарь словарей database в список словарей
        # В итоге должен быть [dict, dict, dict, ...], где dict - словарь продукта из database
    if ordering_key is not None:
        ... #  TODO Проведите сортировку result по ordering_key и параметру reverse
        # Так как result будет списком, то можно применить метод sort, но нужно определиться с тем по какому элементу сортируем и в каком направлении
        # result.sort(key=lambda ..., reverse=reverse)
        # Вспомните как можно сортировать по значениям словаря при помощи lambda функции
    return result


if __name__ == "__main__":
    from store.models import DATABASE

    test = [
        {'name': 'Клубника', 'discount': None, 'price_before': 500.0,
         'price_after': 500.0,
         'description': 'Сладкая и ароматная клубника, полная витаминов, чтобы сделать ваш день ярче.',
         'rating': 5.0, 'review': 200, 'sold_value': 700,
         'weight_in_stock': 400,
         'category': 'Фрукты', 'id': 2, 'url': 'store/images/product-2.jpg',
         'html': 'strawberry'},
        
        {'name': 'Яблоки', 'discount': None, 'price_before': 130.0,
         'price_after': 130.0,
         'description': 'Сочные и сладкие яблоки - идеальная закуска для здорового перекуса.',
         'rating': 4.7, 'review': 30, 'sold_value': 70, 'weight_in_stock': 200,
         'category': 'Фрукты', 'id': 10, 'url': 'store/images/product-10.jpg',
         'html': 'apple'}
    ]

    print(filtering_category(DATABASE, 'Фрукты', 'price_after', True) == test)  # True
```

Далее допишем представление `products_view` во `views.py` приложения `store`.

Во `views.py` приложения `store` импортируйте `filtering_category` из `logic.services`

Ниже приведена заготовка с разветвлениями, которую необходимо заполнить для корректной работы. В целом необходимо правильно
прописать значения в переменной `data` в ветке `if category_key := request.GET.get("category"):`. 
Ветку `if id_product := request.GET.get("id"):` вы уже реализовывали ранее.

Внимательно проверьте правильно ли вы работаете с условиями. Так как в обработчике `products_view` сначала проверяется
есть ли параметр `id` в адресной строке, а только затем (если `id` нет в адресной строке среди переданных 
пользователем параметров) вы проверяете параметры category, ordering и reverse. Обратите внимание, чтобы 
`HttpResponseNotFound("Данного продукта нет в базе данных")` написанный вами ранее корректно отрабатывался.

```python
from logic.services import filtering_category

def products_view(request):
    if request.method == "GET":
        # Обработка id из параметров запроса (уже было реализовано ранее)
        if id_product := request.GET.get("id"):
            if data := DATABASE.get(id_product):
                return JsonResponse(data, json_dumps_params={'ensure_ascii': False,
                                                             'indent': 4})
            return HttpResponseNotFound("Данного продукта нет в базе данных")

        # Обработка фильтрации из параметров запроса
        category_key = request.GET.get("category")  # Считали 'category' 
        if ordering_key := request.GET.get("ordering"): # Если в параметрах есть 'ordering'
            if request.GET.get("reverse").lower() == 'true': # Если в параметрах есть 'ordering' и 'reverse'=True
                data = ... #  TODO Использовать filtering_category и провести фильтрацию с параметрами category, ordering, reverse=True  
            else:  # Если не обнаружили в адресно строке ...&reverse=true , значит reverse=False
                data = ... #  TODO Использовать filtering_category и провести фильтрацию с параметрами category, ordering, reverse=False
        else:
            data = ... #  TODO Использовать filtering_category и провести фильтрацию с параметрами category
        # В этот раз добавляем параметр safe=False, для корректного отображения списка в JSON
        return JsonResponse(data, safe=False, json_dumps_params={'ensure_ascii': False,
                                                                 'indent': 4})
```

Проверьте работу вашего представления:

* http://127.0.0.1:8000/product?category=Фрукты&ordering=price_after&reverse=True


* http://127.0.0.1:8000/product?category=Фрукты&ordering=price_after


* http://127.0.0.1:8000/product?category=Овощи

Можете самостоятельно придумать параметры для фильтрации, допустим:

* Можете вывести все продукты в порядке убывания рейтинга продукта

### 5. Работа с корзиной товаров

Товары есть, фильтрация есть, можно даже каждый товар открыть посмотреть на него. 

Настало время добавить товар в корзину!

Однако мы с вами снова пойдём реализации со стороны серверной части, а отображение в HTML оставим на следующую практику.

В отличии, от корзины - база данных наших товаров не меняется со временем. В корзину как добавляют товары, 
так и удаляют из нёё. 

Желательно чтобы от перезапуска сервера наша корзина не приходила в начальное состояние(пустая),
а сохраняла то, что мы туда положили ранее.

Поэтому в этот раз воспользуемся файлом в виде базы данных в которой будем хранить нашу информацию. Хранить 
информацию будем в файле `cart.json`.

В файле `services.py` напишем функции `view_in_cart`, `add_to_cart`, `remove_from_cart`  которые реализуют действия по
просмотру, добавлению и удалению товаров из корзины. 

Функция `view_in_cart` уже реализована, необходимо дописать 
`add_to_cart`, `remove_from_cart`

```python
import json
import os
from store.models import DATABASE

# def filtering_category(...)  Ваша реализация filtering_category 

def view_in_cart() -> dict:  # Уже реализовано, не нужно здесь ничего писать
    """
    Просматривает содержимое cart.json

    :return: Содержимое 'cart.json'
    """
    if os.path.exists('cart.json'):  # Если файл существует
        with open('cart.json', encoding='utf-8') as f:
            return json.load(f)

    cart = {'products': {}}  # Создаём пустую корзину
    with open('cart.json', mode='x', encoding='utf-8') as f:   # Создаём файл и записываем туда пустую корзину
        json.dump(cart, f)

    return cart


def add_to_cart(id_product: str) -> bool:
    """
    Добавляет продукт в корзину. Если в корзине нет данного продукта, то добавляет его с количеством равное 1.
    Если в корзине есть такой продукт, то добавляет количеству данного продукта + 1.

    :param id_product: Идентификационный номер продукта в виде строки.
    :return: Возвращает True в случае успешного добавления, а False в случае неуспешного добавления(товара по id_product
    не существует).
    """
    cart = ...  # TODO Помните, что у вас есть уже реализация просмотра корзины,
    # поэтому, чтобы загрузить данные из корзины, не нужно заново писать код.
    
    # ! Обратите внимание, что в переменной cart находится словарь с ключом products.
    # ! Именно в cart["products"] лежит словарь гдк по id продуктов можно получить число продуктов в корзине.
    # ! Т.е. чтобы обратиться к продукту с id_product = "1" в переменной cart нужно вызвать
    # ! cart["products"][id_product]
    # ! Далее уже сами решайте как и в какой последовательности дальше действовать. 
    
    # TODO Проверьте, а существует ли такой товар в корзине, если нет, то перед тем как его добавить - проверьте есть ли такой id_product товара в вашей базе данных DATABASE, чтобы уберечь себя от добавления несуществующего товара.

    # TODO Если товар существует, то увеличиваем его количество на 1

    # TODO Не забываем записать обновленные данные cart в 'cart.json'. Так как именно из этого файла мы считываем данные и если мы не запишем изменения, то считать измененные данные не получится.

    return True


def remove_from_cart(id_product: str) -> bool:
    """
    Добавляет позицию продукта из корзины. Если в корзине есть такой продукт, то удаляется ключ в словаре
    с этим продуктом.

    :param id_product: Идентификационный номер продукта в виде строки.
    :return: Возвращает True в случае успешного удаления, а False в случае неуспешного удаления(товара по id_product
    не существует).
    """
    cart = ...  # TODO Помните, что у вас есть уже реализация просмотра корзины,
    # поэтому, чтобы загрузить данные из корзины, не нужно заново писать код.
    
    # С переменной cart функции remove_from_cart ситуация аналогичная, что с cart функции add_to_cart
    
    # TODO Проверьте, а существует ли такой товар в корзине, если нет, то возвращаем False.

    # TODO Если существует товар, то удаляем ключ 'id_product' у cart['products'].

    # TODO Не забываем записать обновленные данные cart в 'cart.json'

    return True


if __name__ == "__main__":
    # Проверка работоспособности функций view_in_cart, add_to_cart, remove_from_cart
    # Для совпадения выходных значений перед запуском скрипта удаляйте появляющийся файл 'cart.json' в папке
    print(view_in_cart())  # {'products': {}}
    print(add_to_cart('1'))  # True
    print(add_to_cart('0'))  # False
    print(add_to_cart('1'))  # True
    print(add_to_cart('2'))  # True
    print(view_in_cart())  # {'products': {'1': 2, '2': 1}}
    print(remove_from_cart('0'))  # False
    print(remove_from_cart('1'))  # True
    print(view_in_cart())  # {'products': {'2': 1}}

    # Предыдущий код, что был для проверки filtering_category закомментируйте
```

Финалом практики будет составление представления, которое будет обрабатывать запросы и работать с `cart.json`

Какие представления нам нужны? Те, что будут обрабатывать 3 функции, поэтому создадим 3 представления во `views.py` 
приложения `store`. 

* `cart_view` - возвращает JSON с корзиной


* `cart_add_view` - добавляет в корзину товар по его `id_product`


* `cart_del_view` - удаляет товар из корзины по его `id_product`

Используйте и заполните предложенный шаблон

```python
from logic.services import view_in_cart, add_to_cart, remove_from_cart


def cart_view(request):
    if request.method == "GET":
        data = ... # TODO Вызвать ответственную за это действие функцию
        return JsonResponse(data, json_dumps_params={'ensure_ascii': False,
                                                     'indent': 4})


def cart_add_view(request, id_product):
    if request.method == "GET":
        result = ... # TODO Вызвать ответственную за это действие функцию и передать необходимые параметры
        if result:
            return JsonResponse({"answer": "Продукт успешно добавлен в корзину"},
                                json_dumps_params={'ensure_ascii': False})

        return JsonResponse({"answer": "Неудачное добавление в корзину"},
                            status=404,
                            json_dumps_params={'ensure_ascii': False})


def cart_del_view(request, id_product):
    if request.method == "GET":
        result = ... # TODO Вызвать ответственную за это действие функцию и передать необходимые параметры
        if result:
            return JsonResponse({"answer": "Продукт успешно удалён из корзины"},
                                json_dumps_params={'ensure_ascii': False})

        return JsonResponse({"answer": "Неудачное удаление из корзины"},
                            status=404,
                            json_dumps_params={'ensure_ascii': False})
```

Осталось только прописать маршруты в `urls.py` приложения `store`. Строковый тип `id_product` передаём за счет `str`

```python
    path('cart/', cart_view),
    path('cart/add/<str:id_product>', cart_add_view),
    path('cart/del/<str:id_product>', cart_del_view),
```

Протестируйте правильность выполнения запросов.

### Практика окончена

Зафиксируем изменения сделав коммит и отправим эти коммиты на github